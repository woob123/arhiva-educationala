---
id: OJI-2025-X-bitsir
title: Solu탵ia problemei Bitsir (OJI 2025, clasa a X-a)
problem_id: 3633
authors: [dobleaga]
prerequisites:
    - bitwise-ops
tags:
    - OJI
    - clasa X
---

## Subtask 1

C칙nd $X = 0$, 탳irul $A_i$ trebuie s캒 fie plin de 0 ($A_i = 0,\,\forall i \in {1,
2, \dots , N }$). Fiindc캒 $Y = 0$, iar $M_i = 0,\,\forall i \in {1, 2, \dots ,
N}$, r캒spunsul va fi mereu 1.

## Subtask 2

C칙nd 洧녦 = 1, 탳irul $A_i$ trebuie s캒 con탵in캒 cel pu탵in o valoare de 1, restul
fiind egale cu 0. Din moment ce $Y = 0$, num캒rul de valori de 1 trebuie s캒 fie
par. Astfel, r캒spunsul va fi $C_N^2 + C_N^4 + ... = 2^{N-1} - 1$.

## Subtask 3

Observa탵ie: 탳irul $A_i$ nu poate avea elemente mai mari dec칙t $X$. Pentru acest
subtask, se creeaz캒 un for pentru fiecare valoare de la 0 la $X$ 탳i se verific캒
toate condi탵iile.

## Subtask 4

O generalizare a subtaskului 1, trebuie verificat dac캒 탳irul plin de 0 respect캒
propriet캒탵ile 2 탳i 3.

## Subtask 5

Pe baza observa탵iei anterioare 탳i a m캒rimii 탳irului ($N \leq 4$), solu탵ia pentru
acest subtask este iterarea prin toate posibilit캒탵ile 탳i verificarea celor 3
condi탵ii.

Complexitate: $\mathcal{O}(X^4)$ ca timp.

## Subtask 6

!!! note "Observa탵ie"

    Opera탵ia de XOR ($\oplus$) are urm캒toarea proprietate: $a \oplus b = c
    \Rightarrow a = b \oplus c$.

Se itereaz캒 prin toate valorile posibile ale lui $A_1$ ($\{0, 1, \dots X\}$), se
afl캒 valoarea lui $A_2 = Y \oplus A_1$ 탳i se verific캒 celelalte dou캒 condi탵ii.

Complexitate: $\mathcal{O}(X)$.

## Subtask 7

칉n acest caz, cele 3 condi탵ii pot fi reformulate astfel:

- Dac캒 $X = 1$, atunci exist캒 cel pu탵in o valoare de 1 칥n 탳ir, altfel tot 탳irul
  este complet 0.
- Dac캒 $Y = 1$, atunci exist캒 un num캒r impar de 1 칥n 탳ir, altfel exist캒 un num캒r
  par de 1.
- Dac캒 $M_i = 1$, atunci $A_i$ = 1, altfel $A_i$ poate fi 0 sau 1.

Dac캒 $X = 0$, atunci problema se reduce la Subtaskul 4. Altfel, 칥n func탵ie de
valoarea lui $Y$ 탳i c칙te valori de 1 exist캒 칥n 탳irul $M$, se determin캒 paritatea
num캒rului de valori care pot fi alese. Mai exact, dac캒 se noteaz캒 cu $F$ num캒rul
de valori de 1 din 탳irul $M$ 탳i cu $R$ r캒spunsul, exist캒 urm캒toarele cazuri:

- $F$ impar 탳i $Y = 0$: $R = C_1^{N-F} + C_3^{N-F} + \dots = 2^{N - F - 1}$
- $F$ impar 탳i $Y = 1$: $R = C_0^{N-F} + C_2^{N-F} + \dots = 2^{N - F - 1}$
- $F$ par 탳i $Y = 0$: $R = C_0^{N-F} + C_2^{N-F} + \dots = 2^{N - F - 1}$
- $F$ par 탳i $Y = 1$: $R = C_1^{N-F} + C_3^{N-F} + \dots = 2^{N - F - 1}$

Dac캒 $X = 1$, $F = 0$ 탳i $Y = 0$, atunci la formul캒 se scade 1 deoarece se
칥nnum캒r캒 탳i 탳irul plin de 0.

Complexitate: $\mathcal{O}(N)$

## Subtask 8

Din cauza naturii opera탵iilor pe bi탵i, problema poate fi rezolvat캒 bit cu bit,
fiind 칥mp캒r탵it캒 astfel 칥n 30 de subprobleme de tipul subtaskului 7. Mai exact,
pentru bitul $b$, subproblema este urm캒toarea:

- $X_b = 1$, dac캒 $X$ con탵ine bitul $b$, altfel $X_b = 0$.
- $Y_b = 1$, dac캒 $Y$ con탵ine bitul $b$, altfel $Y_b = 0$.
- $M_i = 1$, dac캒 $M_i$ con탵ine bitul $b$, altfel $M_b = 0$.

Se rezolv캒 toate subproblemele, iar r캒spunsul final va fi produsul tuturor
r캒spunsurilor subproblemelor.

## Rezolvare

Mai jos pute탵i g캒si o solu탵ie care ia punctajul maxim.

```cpp
#include <bits/stdc++.h>

using namespace std;

ifstream f("bitsir.in");
ofstream g("bitsir.out");

typedef long long LL;
constexpr int NMAX = 1e5 + 5;
constexpr int MOD = 1e9 + 7;

int N;
LL X, Y;
LL Mask[NMAX];

int fact[NMAX];
int inv_fact[NMAX];

int LgPut(int a, int b) {
    if (b == 1) {
        return a;
    }

    if (b == 0) {
        return 1;
    }

    int val = LgPut(a, b / 2);

    val = (1LL * val * val) % MOD;

    if (b % 2 == 1) {
        return (1LL * val * a) % MOD;
    }

    return val;
}

void Precalculare() {
    fact[0] = 1;

    for (int i = 1; i <= N; ++i) {
        fact[i] = (1LL * fact[i - 1] * i) % MOD;
    }
    inv_fact[N] = LgPut(fact[N], MOD - 2);

    for (int i = N - 1; i >= 0; --i) {
        inv_fact[i] = (1LL * inv_fact[i + 1] * (i + 1)) % MOD;
    }
}

int Comb(int n, int k) {
    int ans = (1LL * inv_fact[k] * inv_fact[n - k]) % MOD;

    return (1LL * ans * fact[n]) % MOD;
}

int main() {
    f >> N >> X >> Y;

    for (int i = 1; i <= N; ++i) {
        f >> Mask[i];
    }

    if (Y > X) {
        g << "NU\n" << 0;
        return 0;
    }
    Precalculare();

    int answer = 1;
    for (int b = 0; (1LL << b) <= X; ++b) {
        if ((X & (1LL << b)) == 0) {
            for (int i = 1; i <= N; ++i) {
                if ((Mask[i] & (1LL << b))) {
                    g << "NU\n" << 0;
                    return 0;
                }
            }

            if ((Y & (1LL << b))) {
                g << "NU\n" << 0;
                return 0;
            }

            continue;
        }

        int start = 0;
        if ((Y & (1LL << b))) {
            start = 1;
        }

        int cnt_forced_one = 0;
        for (int i = 1; i <= N; ++i) {
            if ((Mask[i] & (1LL << b))) {
                cnt_forced_one++;
            }
        }

        if (cnt_forced_one % 2 == 1) {
            start = (1 - start);
        }

        int n = N - cnt_forced_one;
        bool exists_one = (cnt_forced_one > 0);

        if (!exists_one && start == 0) {
            start += 2;
        }

        int coef = 0;
        for (int i = start; i <= n; i += 2) {
            coef = (1LL * coef + 1LL * Comb(n, i)) % MOD;
        }

        if (coef == 0) {
            g << "NU\n" << 0;
            return 0;
        }
        answer = (1LL * answer * coef) % MOD;
    }

    g << "DA\n" << answer;

    return 0;
}
```
